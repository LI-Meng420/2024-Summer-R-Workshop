left_join(unnest_tb2, by = c("chinese_name", "short_name_id"))
unnest_tb1 %>%
select(chinese_name, short_name, short_name_id) %>%
left_join(unnest_tb2, by = c("chinese_name", "short_name_id")) %>%
select(-short_name_id)
unnest_tb1 %>%
select(chinese_name, short_name, short_name_id) %>%
left_join(unnest_tb2, by = c("chinese_name", "short_name_id")) %>%
select(-short_name_id) %>%
print(n = Inf)
unnest_tb1 %>%
select(chinese_name, short_name, short_name_id) %>%
left_join(unnest_tb2, by = c("chinese_name", "short_name_id")) %>%
select(-short_name_id) %>%
filter(chinese_name != short_name) %>%
mutate(
origin_of_short_name = value_if_na(origin_of_short_name, "缩略")
)
unnest_tb1 %>%
select(chinese_name, short_name, short_name_id) %>%
left_join(unnest_tb2, by = c("chinese_name", "short_name_id")) %>%
select(-short_name_id) %>%
filter(chinese_name != short_name) %>%
mutate(
origin_of_short_name = value_if_na(origin_of_short_name, "缩略")
) %>%
print(n = Inf)
short_tb <- unnest_tb1 %>%
select(chinese_name, short_name, short_name_id) %>%
left_join(unnest_tb2, by = c("chinese_name", "short_name_id")) %>%
select(-short_name_id) %>%
filter(chinese_name != short_name) %>%
mutate(
origin_of_short_name = value_if_na(origin_of_short_name, "缩略")
)
short_tb %>%
print(n = Inf)
abbr_tb <- unnest_tb1 %>%
select(chinese_name, short_name, short_name_id) %>%
left_join(unnest_tb2, by = c("chinese_name", "short_name_id")) %>%
select(-short_name_id) %>%
filter(chinese_name != short_name) %>%
mutate(
origin_of_short_name = value_if_na(origin_of_short_name, "缩略")
)
abbr_tb %>%
print(n = Inf)
abbr_tb %>%
mutate(
source = case_when(
str_detect(origin_of_short_name, "缩略") ~ "缩略",
str_detect(origin_of_short_name, "古") ~ "古称",
TRUE ~ "山河"
)
) %>%
relocate(source, .after = origin_of_short_name)
abbr_tb %>%
mutate(
source = case_when(
str_detect(origin_of_short_name, "缩略") ~ "缩略",
str_detect(origin_of_short_name, "古") ~ "古称",
str_detect(origin_of_short_name, "[山河]") ~ "山河",
str_detect(origin_of_short_name, "封地") ~ "封地"
)
) %>%
relocate(source, .after = origin_of_short_name)
abbr_tb %>%
mutate(
source = case_when(
str_detect(origin_of_short_name, "缩略") ~ "缩略",
str_detect(origin_of_short_name, "古") ~ "古称",
str_detect(origin_of_short_name, "[山河]") ~ "山河",
str_detect(origin_of_short_name, "封地") ~ "封地"
)
) %>%
relocate(source, .after = origin_of_short_name) %>%
print(n = Inf)
abbr_tb %>%
mutate(
source = case_when(
str_detect(origin_of_short_name, "缩略") ~ "缩略",
str_detect(origin_of_short_name, "古") ~ "古称",
str_detect(origin_of_short_name, "[山河]") ~ "山河",
str_detect(origin_of_short_name, "封地") ~ "封地"
)
) %>%
tab(source)
abbr_tb %>%
mutate(
source = case_when(
str_detect(origin_of_short_name, "缩略") ~ "缩略",
str_detect(origin_of_short_name, "古") ~ "古称",
str_detect(origin_of_short_name, "[山河]") ~ "山河",
str_detect(origin_of_short_name, "封地") ~ "封地"
)
) %>%
tab(source, .desc = TRUE)
abbr_tb %>%
filter(origin_of_short_name == "缩略") %>%
print(n = Inf)
folder <- "D:/R/Teaching/2024 Summer R Workshop"
styler::style_dir(folder)
###### Load the necessary packages ######
# QUESTION 1. Load tidyverse and statart packages
pacman::p_load(tidyverse, statart)
###### Explore storms data ######
# QUESTION 2. Print the built-in dataset of tidyverse "storms".
# QUESTION 2a. Sort the dataset by date (i.e., year + month + day) and then print_interval().
# QUESTION 2b. Only keep the storm "Dennis" and only keep numeric variables.
data(storms)
###### Explore storms data ######
# QUESTION 2. Print the built-in dataset of tidyverse "storms".
# QUESTION 2a. Sort the dataset by date (i.e., year + month + day) and then print_interval().
# QUESTION 2b. Only keep the storm "Dennis" and only keep numeric variables.
data(storms)
storms
# QUESTION 2a. Sort the dataset by date (i.e., year + month + day + hour) and then print_interval().
storms %>%
arrange(year, month, day, hour) %>%
print_interval()
storms %>%
arrange(year, month, day, hour) %>%
print_headtail()
# QUESTION 2b. Only keep the storm "Dennis" and only keep numeric variables.
storms %>%
filter(name == "Dennis") %>%
select(where(is.numeric))
# QUESTION 2b. Only keep the storm "Dennis" and only keep numeric variables.
storms %>%
filter(name == "Dennis") %>%
select(name, bwhere(is.numeric))
# QUESTION 2b. Only keep the storm "Dennis" and only keep numeric variables.
storms %>%
filter(name == "Dennis") %>%
select(name, where(is.numeric))
# QUESTION 2b. Only keep the storm "Dennis" and only keep numeric variables.
storms %>%
filter(name == "Dennis") %>%
select(name, where(is.numeric))
file.path(path, "hubei_20200301.csv")
# QUESTION 3. Import the dataset "hubei_20200301.csv" as "tb"
path <- "D:/R/Teaching/2024 Summer R Workshop/Week 2/Week 2 Assignment"
file.path(path, "hubei_20200301.csv")
tb <- file.path(path, "hubei_20200301.csv") %>%
read_csv()
tb
glimpse(tb)
# QUESTION 3a. Print the codebook of the dataset with all variables.
codebook(tb)
# QUESTION 3a. Print the codebook of the dataset with all variables.
codebook(tb) %>%
print(n = 32)
# QUESTION 3b. According to the "attributes.csv", select all variables that
#              are related to the location and sort them in alphabetical order.
dict <- file.path(path, "attributes.csv") %>%
read_csv()
dict
view(dict)
tb %>%
select(
travel_history_location, latitude, longitude, geo_resolution,
admin3, admin2, admin1, country_new, admin_id
)
tb %>%
select(
starts_with("admin"),
country_new, geo_resolution,
latitude, longitude, travel_history_location
)
tb %>%
select(
starts_with("admin"),
country_new, geo_resolution,
latitude, longitude, travel_history_location
) %>%
relocate(admin1, admin2)
# Load the required packages and the data
pacman::p_load(tidyverse, statart)
path <- "D:/R/Teaching/2024 Summer R Workshop/Week 3/participants_deidentified.csv"
tb <- read_data(path)
tb
tb %>% names()
# names() or ds() returns a "character vector"
# character vector is a vector of strings; i.e., some strings
# The "type" or "class" of a character vector is "character"
tb %>%
names() %>%
s_type()
1
c(1, 3, 45)
# We did not learn how to edit vectors.
# If necessary, we can as_tibble() a character vector to a tibble
# Also, we can pull() a tibble column to a vector
tb %>%
names() %>%
as_tibble()
# We did not learn how to edit vectors.
# If necessary, we can as_tibble() a character vector to a tibble
# Also, we can pull() a tibble column to a vector
tb %>%
names() %>%
as_tibble() %>%
arrange(value)
tb
tb %>% select(clean_data_result)
tb %>% pull(2)
tb %>% select(2)
# select() is used to select columns
tb %>%
select(starts_with("learn"))
tb %>%
select(s_match("learn*")) # equivalent to starts_with("learn")
tb %>%
select(s_match("learn*")) %>%
names()
tb %>%
ds(s_match("learn*")) # ds() equals select(...) %>% names()
# filter() is used to select rows based on conditions
tb %>%
filter(id > 50)
pull(tb, id)
pull(tb, id) > 50
s_type(pull(tb, id) > 50)
# Other operators for creating logical conditions:
tb %>%
filter(id <= 50)
tb %>%
filter(id == 50)
tb %>%
filter(clean_data_result == "未清洗")
tb %>%
filter(clean_data_result != "未清洗") # ! and = lead to !=
tb %>%
filter(clean_data_result != "未清洗") %>%
nrow() # ! and = lead to !=
tb %>%
filter(clean_data_result != "未清洗") %>%
ncol() # ! and = lead to !=
31:50 # 31, 32, ..., 50
s_type(31:50)
tb %>%
filter(id %in% 31:50) # discrete values
tb %>%
filter(id %in% 31:50) # discrete values
31:50 # 31, 32, ..., 50
tb %>%
filter(prob_clean_data_invalid == NA) # this does not work
# tb %>%
#   filter(prob_clean_data_invalid == NA) # this does not work
#
# NA means "Not Available" or "Not Applicable".
# A value is never equal to NA. Use is.na() instead.
tb %>%
filter(is.na(prob_clean_data_invalid))
tb %>%
filter(!is.na(prob_clean_data_invalid)) # ! means "not"
tb %>%
filter(id >= 31 & id <= 50)
tb %>%
filter(id >= 31 | is.na(prob_clean_data_invalid))
# select() can be used to select columns based on positions
tb %>%
select(1:5) # first 5 columns
tb %>%
select(c(1, 3, 5)) # 1st, 3rd, and 5th columns
# slice() is used to select rows based on positions
tb %>%
slice(1:5) # first 5 rows
tb %>%
slice(c(1, 3, 5)) # 1st, 3rd, and 5th rows
c(1, 3, 5)
1:5
tb %>%
slice(c(1, 3.5, 5)) # 1st, 3rd, and 5th rows
tb %>%
slice_headtail()
tb %>%
slice_interval()
tb %>%
arrange(id) %>%
slice_interval()
tb %>%
slice_sample(n = 5)
tb %>%
sample_n(5)
tb %>%
slice_sample(n = 5)
tb %>%
slice_sample(n = 5) %>%
set_seed(20240618) # set_seed() for reproducibility
tb %>%
slice_sample(n = 5) %>%
set_seed(20240618) # set_seed() for reproducibility
# mutate() is used to modify or create new columns
tb %>%
mutate(id = id + 1000)
# mutate() is used to modify or create new columns
tb %>%
mutate(id = id + 1000)
tb %>%
mutate(id2 = id + 1000) %>%
relocate(id, id2)
tb %>%
mutate(
id1 = id + 1000,
id2 = id + 2000,
id3 = id + 3000
)
tb %>%
mutate(
id1 = id + 1000,
id2 = id + 2000,
id3 = id + 3000
) %>%
relocate(s_match("id*"))
tb %>%
select(s_match("software*"))
tb %>%
filter(!is.na(software_spss))
tb %>%
mutate(
software_spss = !is.na(software_spss),
software_stata = !is.na(software_stata)
) %>%
relocate(s_match("software*"))
# Iterate over columns (advanced topic)
tb %>%
mutate(
across( # across() iterates over columns
s_match("software*"), # select columns
~ !is.na(.) # ~ helps to define a function
)
) %>%
relocate(s_match("software*"))
tb
tb %>%
mutate(
clean_data_result = na_if_value(clean_data_result, "未清洗"),
prob_clean_data_invalid =
value_if_na(prob_clean_data_invalid, "Invalid")
)
tb %>%
mutate(
clean_data_result = na_if_value(clean_data_result, "未清洗"),
prob_clean_data_invalid =
value_if_na(prob_clean_data_invalid, "FALSE")
)
tb %>%
mutate(
clean_data_result = na_if_value(clean_data_result, "未清洗"),
prob_clean_data_invalid =
value_if_na(prob_clean_data_invalid, FALSE)
)
tb %>%
mutate(
id_4g = cut_quantile(id)
)
tb %>%
mutate(
id_4g = cut_quantile(id)
) %>%
tab(id_4g)
tb %>%
mutate(
id_4g = cut_quantile(id),
id_5g = cut_quantile(id, 5)
) %>%
tab(id_5g)
tb %>%
mutate(
id_4g = cut_breaks(
id,
breaks = c(0, 10, 20, 30, 40, 50)
)
)%>%
tab(id_4g)
tb %>%
mutate(
id_4g = cut_breaks(
id, reaks = c(10, 20, 30, 40, 50)
)
)%>%
tab(id_4g)
tb %>%
mutate(
id_4g = cut_breaks(
id, breaks = c(10, 20, 30, 40, 50)
)
)%>%
tab(id_4g)
tb %>%
mutate(
id_6g = cut_breaks(
id, breaks = c(10, 20, 30, 40, 50)
)
) %>%
tab(id_6g)
# If you really want to update the data, use the assignment operator <-
tb <- tb %>%
mutate(
id_6g = cut_breaks(
id, breaks = c(10, 20, 30, 40, 50)
)
)
tb %>%
tab(id_6g)
c(TRUE, FALSE)
factor(1:3, labels = c("Disagree", "Neutral", "Agree"))
tibble(
x = factor(1:3, labels = c("Disagree", "Neutral", "Agree")),
y = 1:3
) %>%
regress()
tibble(
x = factor(1:3, labels = c("Disagree", "Neutral", "Agree")),
y = 1:3
) %>%
regress(y ~ x)
tibble(
x = factor(c(1:3, 3), labels = c("Disagree", "Neutral", "Agree")),
y = 1:4
) %>%
regress(y ~ x)
tmp_tb <- tibble(
x = factor(c(1:3, 3), labels = c("Disagree", "Neutral", "Agree")),
y = 1:4
)
tmp_tb
tmp_tb %>%
regress_coef(y ~ x)
seq(10, 50, by = 10)
seq(10, 50, 10)
10:50
1:5
1:5*10
tb
# summ() is used for continuous variables
tb %>% summ()
tb %>%
tab(id_6g)
tb %>% summ(duration) # only for the duration column
# summ() is used for continuous variables
tb %>% summ(everything())
tb %>% summ(duration) # only for the duration column
tb %>%
# Remove the outlier
filter(duration < 10000)
tb %>%
# Remove the outlier
filter(duration < 10000) %>%
# Convert the duration from seconds to minutes
mutate(
duration = duration / 60
)
tb %>%
# Remove the outlier
filter(duration < 10000) %>%
# Convert the duration from seconds to minutes
mutate(
duration = duration / 60
) %>%
summ(duration)
# ===========================================================
# Quickly plot a histogram of the duration by using s_plot()
tb %>%
filter(duration < 10000) %>%
mutate(
duration = duration / 60
) %>%
# Plot the histogram
s_plot(duration)
tb
# ===========================================================
# tab() is used for categorical variables
tb %>%
tab(clean_data_result)
tb %>%
tab(province)
tb %>%
tab(country, province)
tb %>%
tab1(country, province)
tb %>%
tab2(country, province)
tb %>%
tab2(province, country)
# ===========================================================
# fre() converts the output to a flextable
tb %>%
fre(country, province)
tb %>%
fre1(country, province)
tb %>%
fre2(province, country)
# ===========================================================
# fre() converts the output to a flextable
tb %>%
fre(country, province) %>%
s_type()
tb %>%
tab(country, province)
tb %>%
summarise(
mean_duration = mean(duration),
sd_duration = sd(duration)
)
tb %>% summ(duration) # only for the duration column
tb %>% tabstat(duration)
tb %>%
tabstat(duration, by = country)
tb %>%
tabstat(duration, .by = country)
